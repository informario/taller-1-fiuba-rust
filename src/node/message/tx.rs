use crate::node::message::*;

use super::block::transaction::Transaction;

/// Command for tx message.
pub const COMMAND: [u8; 12] = *b"tx\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

/// Struct containing parameters for tx message.
/// ```
struct MessageParams {
    transaction: Transaction,
}

/// https://developer.bitcoin.org/reference/p2p_networking.html#tx
/// The “tx” message transmits a single transaction in the raw transaction format. It can be sent in a variety of situations;
///     - Transaction Response: Bitcoin Core and BitcoinJ will send it in response to a “getdata” message that requests the
///         transaction with an inventory type of “MSG_TX”.
///     - MerkleBlock Response: Bitcoin Core will send it in response to a “getdata” message that requests a merkle block with
///         an inventory type of MSG_MERKLEBLOCK. (This is in addition to sending a “merkleblock” message.) Each “tx” message
///         in this case provides a matched transaction from that block.
///     - Unsolicited: BitcoinJ will send a “tx” message unsolicited for transactions it originates.
///
/// Creates a payload for a tx message.
/// If the parameters are valid, a vector of `DataTypes` is returned. If the parameters are invalid,
/// an `std::io::Error` is returned.
///
/// # Arguments
///
/// * `params` - A vector of parameters to be used in the message. The parameters should be a vector of InvVector DataTypes.
///
/// ```
pub fn create_payload(
    params: Vec<DataTypes>,
) -> Result<Vec<DataTypes>, Box<dyn std::error::Error>> {
    let message_params = parse_params(params)?;

    // Add Transaction
    let payload = vec![DataTypes::Transaction(message_params.transaction)];
    Ok(payload)
}

/// Parses the parameters for a tx message.
/// If the parameters are valid, a `MessageParams` struct is returned. If the parameters are invalid,
/// an `std::io::Error` is returned.
///
/// # Arguments
///
/// * `params` - A vector of parameters to be used in the message.
///
/// ```
fn parse_params(params: Vec<DataTypes>) -> Result<MessageParams, Box<dyn std::error::Error>> {
    // Check if the number of parameters is correct
    if params.len() != 1 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            format!(
                "Invalid number of parameters for tx message. Expected 1, got {}",
                params.len()
            ),
        )
        .into());
    }

    // Check if the parameters are correct
    let transaction = match &params[0] {
        DataTypes::Transaction(transaction) => transaction,
        _ => {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "Invalid parameter type for tx message. Expected Transaction.",
            )
            .into())
        }
    };

    Ok(MessageParams {
        transaction: transaction.clone(),
    })
}

/// Deserializes a tx message payload.
pub fn deserialize_payload(
    serialized_payload: &Vec<u8>,
) -> Result<Vec<DataTypes>, Box<dyn std::error::Error>> {
    let mut message_payload = Vec::<DataTypes>::new();

    // Deserialize Transaction
    let (transaction, consumed) = block::transaction::Transaction::deserialize(serialized_payload)?;
    if consumed != serialized_payload.len() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Invalid tx message. Sent too many bytes.",
        )
        .into());
    }
    message_payload.push(DataTypes::Transaction(transaction));
    Ok(message_payload)
}

#[cfg(test)]
mod tests {
    use crate::node::message::block::transaction::{
        transaction_input::TransactionInput, transaction_output::TransactionOutput, Witness,
    };

    #[test]
    fn test_tx_deserialize() {
        use super::*;

        let serialized = [
            0x02, 0x00, 0x00, 0x00, // Version
            0x00, // Witness marker
            0x01, // Witness flag
            0x01, // Input count
            0x40, 0xd4, 0x3a, 0x99, 0x92, 0x6d, 0x43, 0xeb, 0x0e, 0x61, 0x9b, 0xf0, 0xb3, 0xd8,
            0x3b, 0x4a, 0x31, 0xf6, 0x0c, 0x17, 0x6b, 0xee, 0xcf, 0xb9, 0xd3, 0x5b, 0xf4, 0x5e,
            0x54, 0xd0, 0xf7, 0x42, // Previous output hash
            0x01, 0x00, 0x00, 0x00, // Previous output index
            0x17, // Script length
            0x16, 0x00, 0x14, 0xa4, 0xb4, 0xca, 0x48, 0xde, 0x0b, 0x3f, 0xff, 0xc1, 0x54, 0x04,
            0xa1, 0xac, 0xdc, 0x8d, 0xba, 0xae, 0x22, 0x69, 0x55, // Script
            0xff, 0xff, 0xff, 0xff, // Sequence
            0x01, // Output count
            0x00, 0xe1, 0xf5, 0x05, 0x00, 0x00, 0x00, 0x00, // Value
            0x17, // Script length
            0xa9, 0x14, 0x4a, 0x11, 0x54, 0xd5, 0x0b, 0x03, 0x29, 0x2b, 0x30, 0x24, 0x37, 0x09,
            0x01, 0x71, 0x94, 0x6c, 0xb7, 0xcc, 0xcc, 0x38, 0x70, // Script
            0x02, // Witness count
            72,   // Witness 1 length
            0x04, 0x50, 0x22, 0x10, 0x08, 0x60, 0x4e, 0xf8, 0xf6, 0xd8, 0xaf, 0xa8, 0x92, 0xde,
            0xe0, 0xf3, 0x12, 0x59, 0xb6, 0xce, 0x02, 0xdd, 0x70, 0xc5, 0x45, 0xcf, 0xcf, 0xed,
            0x81, 0x48, 0x17, 0x99, 0x71, 0x87, 0x6c, 0x54, 0xa0, 0x22, 0x07, 0x6d, 0x77, 0x1d,
            0x6e, 0x91, 0xbe, 0xd2, 0x12, 0x78, 0x3c, 0x9b, 0x06, 0xe0, 0xde, 0x60, 0x0f, 0xab,
            0x2d, 0x51, 0x8f, 0xad, 0x6f, 0x15, 0xa2, 0xb1, 0x91, 0xd7, 0xfb, 0xd2, 0x62, 0xa3,
            0xe0, 0x12, // Witness 1
            33,   // Witness 2 length
            0x39, 0xd2, 0x5a, 0xb7, 0x9f, 0x41, 0xf7, 0x5c, 0xea, 0xf8, 0x82, 0x41, 0x1f, 0xd4,
            0x1f, 0xa6, 0x70, 0xa4, 0xc6, 0x72, 0xc2, 0x3f, 0xfa, 0xf0, 0xe3, 0x61, 0xa9, 0x69,
            0xcd, 0xe0, 0x69, 0x2e, 0x80, // Witness 2
            0x00, 0x00, 0x00, 0x00, // Lock time
        ];
        let (tx, _) = Transaction::deserialize(&serialized).unwrap();
        assert_eq!(tx.version, 2);
        assert_eq!(tx.witness.clone().unwrap().witness_marker, 0);
        assert_eq!(tx.witness.clone().unwrap().witness_flag, 1);
        assert_eq!(tx.input_count.to_u128(), 1);
        assert_eq!(tx.output_count.to_u128(), 1);
        assert_eq!(tx.lock_time, 0);
        assert_eq!(tx.inputs.len(), 1);
        assert_eq!(tx.outputs.len(), 1);
        assert_eq!(
            tx.inputs[0],
            TransactionInput::new(
                [
                    0x40, 0xd4, 0x3a, 0x99, 0x92, 0x6d, 0x43, 0xeb, 0x0e, 0x61, 0x9b, 0xf0, 0xb3,
                    0xd8, 0x3b, 0x4a, 0x31, 0xf6, 0x0c, 0x17, 0x6b, 0xee, 0xcf, 0xb9, 0xd3, 0x5b,
                    0xf4, 0x5e, 0x54, 0xd0, 0xf7, 0x42,
                ],
                1,
                CompactSize::OneByte(23),
                vec![
                    0x16, 0x00, 0x14, 0xa4, 0xb4, 0xca, 0x48, 0xde, 0x0b, 0x3f, 0xff, 0xc1, 0x54,
                    0x04, 0xa1, 0xac, 0xdc, 0x8d, 0xba, 0xae, 0x22, 0x69, 0x55
                ],
                u32::from_le_bytes([0xff, 0xff, 0xff, 0xff]),
            )
        );
        assert_eq!(
            tx.outputs[0],
            TransactionOutput::new(
                u64::from_le_bytes([0x00, 0xe1, 0xf5, 0x05, 0x00, 0x00, 0x00, 0x00]),
                CompactSize::OneByte(23),
                vec![
                    0xa9, 0x14, 0x4a, 0x11, 0x54, 0xd5, 0x0b, 0x03, 0x29, 0x2b, 0x30, 0x24, 0x37,
                    0x09, 0x01, 0x71, 0x94, 0x6c, 0xb7, 0xcc, 0xcc, 0x38, 0x70,
                ],
            )
        );
        assert_eq!(
            tx.witness.unwrap().witnesses,
            vec![vec![
                vec![
                    0x04, 0x50, 0x22, 0x10, 0x08, 0x60, 0x4e, 0xf8, 0xf6, 0xd8, 0xaf, 0xa8, 0x92,
                    0xde, 0xe0, 0xf3, 0x12, 0x59, 0xb6, 0xce, 0x02, 0xdd, 0x70, 0xc5, 0x45, 0xcf,
                    0xcf, 0xed, 0x81, 0x48, 0x17, 0x99, 0x71, 0x87, 0x6c, 0x54, 0xa0, 0x22, 0x07,
                    0x6d, 0x77, 0x1d, 0x6e, 0x91, 0xbe, 0xd2, 0x12, 0x78, 0x3c, 0x9b, 0x06, 0xe0,
                    0xde, 0x60, 0x0f, 0xab, 0x2d, 0x51, 0x8f, 0xad, 0x6f, 0x15, 0xa2, 0xb1, 0x91,
                    0xd7, 0xfb, 0xd2, 0x62, 0xa3, 0xe0, 0x12,
                ],
                vec![
                    0x39, 0xd2, 0x5a, 0xb7, 0x9f, 0x41, 0xf7, 0x5c, 0xea, 0xf8, 0x82, 0x41, 0x1f,
                    0xd4, 0x1f, 0xa6, 0x70, 0xa4, 0xc6, 0x72, 0xc2, 0x3f, 0xfa, 0xf0, 0xe3, 0x61,
                    0xa9, 0x69, 0xcd, 0xe0, 0x69, 0x2e, 0x80,
                ]
            ]]
        );
    }

    #[test]
    fn test_tx_create_payload() {
        use super::*;

        // Test correct payload
        let params = vec![DataTypes::Transaction(Transaction::new(
            2,
            CompactSize::OneByte(1),
            vec![TransactionInput::new(
                [
                    0x40, 0xd4, 0x3a, 0x99, 0x92, 0x6d, 0x43, 0xeb, 0x0e, 0x61, 0x9b, 0xf0, 0xb3,
                    0xd8, 0x3b, 0x4a, 0x31, 0xf6, 0x0c, 0x17, 0x6b, 0xee, 0xcf, 0xb9, 0xd3, 0x5b,
                    0xf4, 0x5e, 0x54, 0xd0, 0xf7, 0x42,
                ],
                1,
                CompactSize::OneByte(23),
                vec![
                    0x16, 0x00, 0x14, 0xa4, 0xb4, 0xca, 0x48, 0xde, 0x0b, 0x3f, 0xff, 0xc1, 0x54,
                    0x04, 0xa1, 0xac, 0xdc, 0x8d, 0xba, 0xae, 0x22, 0x69, 0x55,
                ],
                u32::from_le_bytes([0xff, 0xff, 0xff, 0xff]),
            )],
            CompactSize::OneByte(1),
            vec![TransactionOutput::new(
                u64::from_le_bytes([0x00, 0xe1, 0xf5, 0x05, 0x00, 0x00, 0x00, 0x00]),
                CompactSize::OneByte(23),
                vec![
                    0xa9, 0x14, 0x4a, 0x11, 0x54, 0xd5, 0x0b, 0x03, 0x29, 0x2b, 0x30, 0x24, 0x37,
                    0x09, 0x01, 0x71, 0x94, 0x6c, 0xb7, 0xcc, 0xcc, 0x38, 0x70,
                ],
            )],
            0,
            Some(Witness::new(
                vec![vec![
                    vec![
                        0x04, 0x50, 0x22, 0x10, 0x08, 0x60, 0x4e, 0xf8, 0xf6, 0xd8, 0xaf, 0xa8,
                        0x92, 0xde, 0xe0, 0xf3, 0x12, 0x59, 0xb6, 0xce, 0x02, 0xdd, 0x70, 0xc5,
                        0x45, 0xcf, 0xcf, 0xed, 0x81, 0x48, 0x17, 0x99, 0x71, 0x87, 0x6c, 0x54,
                        0xa0, 0x22, 0x07, 0x6d, 0x77, 0x1d, 0x6e, 0x91, 0xbe, 0xd2, 0x12, 0x78,
                        0x3c, 0x9b, 0x06, 0xe0, 0xde, 0x60, 0x0f, 0xab, 0x2d, 0x51, 0x8f, 0xad,
                        0x6f, 0x15, 0xa2, 0xb1, 0x91, 0xd7, 0xfb, 0xd2, 0x62, 0xa3, 0xe0, 0x12,
                    ],
                    vec![
                        0x39, 0xd2, 0x5a, 0xb7, 0x9f, 0x41, 0xf7, 0x5c, 0xea, 0xf8, 0x82, 0x41,
                        0x1f, 0xd4, 0x1f, 0xa6, 0x70, 0xa4, 0xc6, 0x72, 0xc2, 0x3f, 0xfa, 0xf0,
                        0xe3, 0x61, 0xa9, 0x69, 0xcd, 0xe0, 0x69, 0x2e, 0x80,
                    ],
                ]],
                0,
                1,
            )),
        ))];
        let payload = create_payload(params).unwrap();

        let expected_payload = vec![DataTypes::Transaction(Transaction::new(
            2,
            CompactSize::OneByte(1),
            vec![TransactionInput::new(
                [
                    0x40, 0xd4, 0x3a, 0x99, 0x92, 0x6d, 0x43, 0xeb, 0x0e, 0x61, 0x9b, 0xf0, 0xb3,
                    0xd8, 0x3b, 0x4a, 0x31, 0xf6, 0x0c, 0x17, 0x6b, 0xee, 0xcf, 0xb9, 0xd3, 0x5b,
                    0xf4, 0x5e, 0x54, 0xd0, 0xf7, 0x42,
                ],
                1,
                CompactSize::OneByte(23),
                vec![
                    0x16, 0x00, 0x14, 0xa4, 0xb4, 0xca, 0x48, 0xde, 0x0b, 0x3f, 0xff, 0xc1, 0x54,
                    0x04, 0xa1, 0xac, 0xdc, 0x8d, 0xba, 0xae, 0x22, 0x69, 0x55,
                ],
                u32::from_le_bytes([0xff, 0xff, 0xff, 0xff]),
            )],
            CompactSize::OneByte(1),
            vec![TransactionOutput::new(
                u64::from_le_bytes([0x00, 0xe1, 0xf5, 0x05, 0x00, 0x00, 0x00, 0x00]),
                CompactSize::OneByte(23),
                vec![
                    0xa9, 0x14, 0x4a, 0x11, 0x54, 0xd5, 0x0b, 0x03, 0x29, 0x2b, 0x30, 0x24, 0x37,
                    0x09, 0x01, 0x71, 0x94, 0x6c, 0xb7, 0xcc, 0xcc, 0x38, 0x70,
                ],
            )],
            0,
            Some(Witness::new(
                vec![vec![
                    vec![
                        0x04, 0x50, 0x22, 0x10, 0x08, 0x60, 0x4e, 0xf8, 0xf6, 0xd8, 0xaf, 0xa8,
                        0x92, 0xde, 0xe0, 0xf3, 0x12, 0x59, 0xb6, 0xce, 0x02, 0xdd, 0x70, 0xc5,
                        0x45, 0xcf, 0xcf, 0xed, 0x81, 0x48, 0x17, 0x99, 0x71, 0x87, 0x6c, 0x54,
                        0xa0, 0x22, 0x07, 0x6d, 0x77, 0x1d, 0x6e, 0x91, 0xbe, 0xd2, 0x12, 0x78,
                        0x3c, 0x9b, 0x06, 0xe0, 0xde, 0x60, 0x0f, 0xab, 0x2d, 0x51, 0x8f, 0xad,
                        0x6f, 0x15, 0xa2, 0xb1, 0x91, 0xd7, 0xfb, 0xd2, 0x62, 0xa3, 0xe0, 0x12,
                    ],
                    vec![
                        0x39, 0xd2, 0x5a, 0xb7, 0x9f, 0x41, 0xf7, 0x5c, 0xea, 0xf8, 0x82, 0x41,
                        0x1f, 0xd4, 0x1f, 0xa6, 0x70, 0xa4, 0xc6, 0x72, 0xc2, 0x3f, 0xfa, 0xf0,
                        0xe3, 0x61, 0xa9, 0x69, 0xcd, 0xe0, 0x69, 0x2e, 0x80,
                    ],
                ]],
                0,
                1,
            )),
        ))];

        assert_eq!(payload, expected_payload);
    }
}
